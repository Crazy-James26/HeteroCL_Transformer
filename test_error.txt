loc("schedule.py":28:0): error: Cannot find Stage sf_attention
loc("schedule.py":194:0): error: operand #0 does not dominate this use
Error: failed to run MLIR lower pipeline, printing module...
loc("schedule.py":194:0): error: operand #0 does not dominate this use
// Verification failed, printing generic form
#map0 = affine_map<() -> (0)>
#map1 = affine_map<(d0, d1) -> (d0, d1)>
#map2 = affine_map<() -> (768)>
#map3 = affine_map<(d0) -> (d0)>
#map4 = affine_map<() -> (12)>
#map5 = affine_map<(d0, d1) -> (0, d1 mod 8, d0, d1 floordiv 8)>
#map6 = affine_map<(d0, d1, d2) -> (d0, d1 * 64 + d2)>
#map7 = affine_map<() -> (64)>
"builtin.module"() ({
  "func.func"() ({
  ^bb0(%arg0: memref<12x768xf32>, %arg1: memref<768x768xf32>, %arg2: memref<768xf32>, %arg3: memref<768x768xf32>, %arg4: memref<768xf32>, %arg5: memref<768x768xf32>, %arg6: memref<768xf32>):
    %0 = "memref.alloc"() {name = "sf_Q", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x768xf32>
    "affine.for"() ({
    ^bb0(%arg7: index):
      "affine.for"() ({
      ^bb0(%arg8: index):
        %7 = "memref.alloc"() {name = "sum", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xf32>
        %8 = "arith.constant"() {value = 0 : i32} : () -> i32
        %9 = "arith.constant"() {unsigned, value = 0 : index} : () -> index
        %10 = "arith.sitofp"(%8) : (i32) -> f32
        "affine.store"(%10, %7) {map = #map0, to = "sum"} : (f32, memref<1xf32>) -> ()
        "affine.for"() ({
        ^bb0(%arg9: index):
          %14 = "arith.constant"() {value = true} : () -> i1
          "scf.if"(%14) ({
            %15 = "affine.load"(%arg0, %arg7, %arg9) {from = "inp", map = #map1} : (memref<12x768xf32>, index, index) -> f32
            %16 = "affine.load"(%arg1, %arg8, %arg9) {from = "Wq", map = #map1} : (memref<768x768xf32>, index, index) -> f32
            %17 = "arith.mulf"(%15, %16) : (f32, f32) -> f32
            %18 = "affine.load"(%7) {from = "sum", map = #map0} : (memref<1xf32>) -> f32
            %19 = "arith.addf"(%17, %18) : (f32, f32) -> f32
            "affine.store"(%19, %7) {map = #map0, to = "sum"} : (f32, memref<1xf32>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "sf_r1", lower_bound = #map0, reduction, step = 1 : i32, upper_bound = #map2} : () -> ()
        %11 = "affine.load"(%7) {from = "sum", map = #map0} : (memref<1xf32>) -> f32
        %12 = "affine.load"(%arg2, %arg8) {from = "Bq", map = #map3} : (memref<768xf32>, index) -> f32
        %13 = "arith.addf"(%11, %12) : (f32, f32) -> f32
        "affine.store"(%13, %0, %arg7, %arg8) {map = #map1, to = "sf_Q"} : (f32, memref<12x768xf32>, index, index) -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "y", lower_bound = #map0, step = 1 : i32, upper_bound = #map2} : () -> ()
      "affine.yield"() : () -> ()
    }) {loop_name = "x", lower_bound = #map0, op_name = "sf_Q", step = 1 : i32, upper_bound = #map4} : () -> ()
    %1 = "memref.alloc"() {name = "sf_K", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x768xf32>
    "affine.for"() ({
    ^bb0(%arg7: index):
      "affine.for"() ({
      ^bb0(%arg8: index):
        %7 = "memref.alloc"() {name = "sum_0", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xf32>
        %8 = "arith.constant"() {value = 0 : i32} : () -> i32
        %9 = "arith.constant"() {unsigned, value = 0 : index} : () -> index
        %10 = "arith.sitofp"(%8) : (i32) -> f32
        "affine.store"(%10, %7) {map = #map0, to = "sum_0"} : (f32, memref<1xf32>) -> ()
        "affine.for"() ({
        ^bb0(%arg9: index):
          %14 = "arith.constant"() {value = true} : () -> i1
          "scf.if"(%14) ({
            %15 = "affine.load"(%arg0, %arg7, %arg9) {from = "inp", map = #map1} : (memref<12x768xf32>, index, index) -> f32
            %16 = "affine.load"(%arg3, %arg8, %arg9) {from = "Wk", map = #map1} : (memref<768x768xf32>, index, index) -> f32
            %17 = "arith.mulf"(%15, %16) : (f32, f32) -> f32
            %18 = "affine.load"(%7) {from = "sum_0", map = #map0} : (memref<1xf32>) -> f32
            %19 = "arith.addf"(%17, %18) : (f32, f32) -> f32
            "affine.store"(%19, %7) {map = #map0, to = "sum_0"} : (f32, memref<1xf32>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "sf_r1", lower_bound = #map0, reduction, step = 1 : i32, upper_bound = #map2} : () -> ()
        %11 = "affine.load"(%7) {from = "sum_0", map = #map0} : (memref<1xf32>) -> f32
        %12 = "affine.load"(%arg4, %arg8) {from = "Bk", map = #map3} : (memref<768xf32>, index) -> f32
        %13 = "arith.addf"(%11, %12) : (f32, f32) -> f32
        "affine.store"(%13, %1, %arg7, %arg8) {map = #map1, to = "sf_K"} : (f32, memref<12x768xf32>, index, index) -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "y_0", lower_bound = #map0, step = 1 : i32, upper_bound = #map2} : () -> ()
      "affine.yield"() : () -> ()
    }) {loop_name = "x_0", lower_bound = #map0, op_name = "sf_K", step = 1 : i32, upper_bound = #map4} : () -> ()
    %2 = "memref.alloc"() {name = "sf_V", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x768xf32>
    "affine.for"() ({
    ^bb0(%arg7: index):
      "affine.for"() ({
      ^bb0(%arg8: index):
        %7 = "memref.alloc"() {name = "sum_1", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xf32>
        %8 = "arith.constant"() {value = 0 : i32} : () -> i32
        %9 = "arith.constant"() {unsigned, value = 0 : index} : () -> index
        %10 = "arith.sitofp"(%8) : (i32) -> f32
        "affine.store"(%10, %7) {map = #map0, to = "sum_1"} : (f32, memref<1xf32>) -> ()
        "affine.for"() ({
        ^bb0(%arg9: index):
          %14 = "arith.constant"() {value = true} : () -> i1
          "scf.if"(%14) ({
            %15 = "affine.load"(%arg0, %arg7, %arg9) {from = "inp", map = #map1} : (memref<12x768xf32>, index, index) -> f32
            %16 = "affine.load"(%arg5, %arg8, %arg9) {from = "Wv", map = #map1} : (memref<768x768xf32>, index, index) -> f32
            %17 = "arith.mulf"(%15, %16) : (f32, f32) -> f32
            %18 = "affine.load"(%7) {from = "sum_1", map = #map0} : (memref<1xf32>) -> f32
            %19 = "arith.addf"(%17, %18) : (f32, f32) -> f32
            "affine.store"(%19, %7) {map = #map0, to = "sum_1"} : (f32, memref<1xf32>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "sf_r1", lower_bound = #map0, reduction, step = 1 : i32, upper_bound = #map2} : () -> ()
        %11 = "affine.load"(%7) {from = "sum_1", map = #map0} : (memref<1xf32>) -> f32
        %12 = "affine.load"(%arg6, %arg8) {from = "Bv", map = #map3} : (memref<768xf32>, index) -> f32
        %13 = "arith.addf"(%11, %12) : (f32, f32) -> f32
        "affine.store"(%13, %2, %arg7, %arg8) {map = #map1, to = "sf_V"} : (f32, memref<12x768xf32>, index, index) -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "y_1", lower_bound = #map0, step = 1 : i32, upper_bound = #map2} : () -> ()
      "affine.yield"() : () -> ()
    }) {loop_name = "x_1", lower_bound = #map0, op_name = "sf_V", step = 1 : i32, upper_bound = #map4} : () -> ()
    %3 = "memref.alloc"() {name = "sf_context", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x768xf32>
    "affine.for"() ({
    ^bb0(%arg7: index):
      "affine.for"() ({
      ^bb0(%arg8: index):
        %7 = "arith.constant"() {value = 0 : i32} : () -> i32
        %8 = "arith.sitofp"(%7) : (i32) -> f32
        "affine.store"(%8, %3, %arg7, %arg8) {map = #map1, to = "sf_context"} : (f32, memref<12x768xf32>, index, index) -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "y_2", lower_bound = #map0, step = 1 : i32, upper_bound = #map2} : () -> ()
      "affine.yield"() : () -> ()
    }) {loop_name = "x_2", lower_bound = #map0, op_name = "sf_context", step = 1 : i32, upper_bound = #map4} : () -> ()
    "affine.for"() ({
    ^bb0(%arg7: index):
      %7 = "memref.alloc"() {name = "sf_Q_i", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x64xf32, #map5>
      "affine.for"() ({
      ^bb0(%arg8: index):
        "affine.for"() ({
        ^bb0(%arg9: index):
          %15 = "affine.load"(%0, %arg8, %arg7, %arg9) {from = "sf_Q", map = #map6} : (memref<12x768xf32>, index, index, index) -> f32
          "affine.store"(%15, %7, %arg8, %arg9) {map = #map1, to = "sf_Q_i"} : (f32, memref<12x64xf32, #map5>, index, index) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "y_3", lower_bound = #map0, step = 1 : i32, upper_bound = #map7} : () -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "x_3", lower_bound = #map0, op_name = "sf_Q_i", step = 1 : i32, upper_bound = #map4} : () -> ()
      %8 = "memref.alloc"() {name = "sf_K_i", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x64xf32, #map5>
      "affine.for"() ({
      ^bb0(%arg8: index):
        "affine.for"() ({
        ^bb0(%arg9: index):
          %15 = "affine.load"(%1, %arg8, %arg7, %arg9) {from = "sf_K", map = #map6} : (memref<12x768xf32>, index, index, index) -> f32
          "affine.store"(%15, %8, %arg8, %arg9) {map = #map1, to = "sf_K_i"} : (f32, memref<12x64xf32, #map5>, index, index) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "y_4", lower_bound = #map0, step = 1 : i32, upper_bound = #map7} : () -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "x_4", lower_bound = #map0, op_name = "sf_K_i", step = 1 : i32, upper_bound = #map4} : () -> ()
      %9 = "memref.alloc"() {name = "sf_V_i", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x64xf32>
      "affine.for"() ({
      ^bb0(%arg8: index):
        "affine.for"() ({
        ^bb0(%arg9: index):
          %15 = "affine.load"(%2, %arg8, %arg7, %arg9) {from = "sf_V", map = #map6} : (memref<12x768xf32>, index, index, index) -> f32
          "affine.store"(%15, %9, %arg8, %arg9) {map = #map1, to = "sf_V_i"} : (f32, memref<12x64xf32>, index, index) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "y_5", lower_bound = #map0, step = 1 : i32, upper_bound = #map7} : () -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "x_5", lower_bound = #map0, op_name = "sf_V_i", step = 1 : i32, upper_bound = #map4} : () -> ()
      %10 = "memref.alloc"() {name = "sf_attention", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x12xf32, #map5>
      "affine.for"() ({
      ^bb0(%arg8: index):
        "affine.for"() ({
        ^bb0(%arg9: index):
          %15 = "memref.alloc"() {name = "sum_2", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xf32>
          %16 = "arith.constant"() {value = 0 : i32} : () -> i32
          %17 = "arith.constant"() {unsigned, value = 0 : index} : () -> index
          %18 = "arith.sitofp"(%16) : (i32) -> f32
          "affine.store"(%18, %15) {map = #map0, to = "sum_2"} : (f32, memref<1xf32>) -> ()
          "affine.for"() ({
          ^bb0(%arg10: index):
            %23 = "arith.constant"() {value = true} : () -> i1
            "scf.if"(%23) ({
              %24 = "affine.load"(%7, %arg8, %arg10) {from = "sf_Q_i", map = #map1} : (memref<12x64xf32, #map5>, index, index) -> f32
              %25 = "affine.load"(%8, %arg9, %arg10) {from = "sf_K_i", map = #map1} : (memref<12x64xf32, #map5>, index, index) -> f32
              %26 = "arith.mulf"(%24, %25) : (f32, f32) -> f32
              %27 = "affine.load"(%15) {from = "sum_2", map = #map0} : (memref<1xf32>) -> f32
              %28 = "arith.addf"(%26, %27) : (f32, f32) -> f32
              "affine.store"(%28, %15) {map = #map0, to = "sum_2"} : (f32, memref<1xf32>) -> ()
              "scf.yield"() : () -> ()
            }, {
            }) : (i1) -> ()
            "affine.yield"() : () -> ()
          }) {loop_name = "sf_r2", lower_bound = #map0, reduction, step = 1 : i32, upper_bound = #map7} : () -> ()
          %19 = "affine.load"(%15) {from = "sum_2", map = #map0} : (memref<1xf32>) -> f32
          %20 = "arith.constant"() {value = 8 : i32} : () -> i32
          %21 = "arith.sitofp"(%20) : (i32) -> f32
          %22 = "arith.divf"(%19, %21) : (f32, f32) -> f32
          "affine.store"(%22, %10, %arg8, %arg9) {map = #map1, to = "sf_attention"} : (f32, memref<12x12xf32, #map5>, index, index) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "y_6", lower_bound = #map0, step = 1 : i32, upper_bound = #map4} : () -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "x_6", lower_bound = #map0, op_name = "sf_attention", step = 1 : i32, upper_bound = #map4} : () -> ()
      %11 = "memref.alloc"() {name = "sf_attn_exp", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x12xf32>
      "affine.for"() ({
      ^bb0(%arg8: index):
        "affine.for"() ({
        ^bb0(%arg9: index):
          %15 = "affine.load"(%10, %arg8, %arg9) {from = "sf_attention", map = #map1} : (memref<12x12xf32, #map5>, index, index) -> f32
          %16 = "math.exp"(%15) : (f32) -> f32
          "affine.store"(%16, %11, %arg8, %arg9) {map = #map1, to = "sf_attn_exp"} : (f32, memref<12x12xf32>, index, index) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "y_7", lower_bound = #map0, step = 1 : i32, upper_bound = #map4} : () -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "x_7", lower_bound = #map0, op_name = "sf_attn_exp", step = 1 : i32, upper_bound = #map4} : () -> ()
      %12 = "memref.alloc"() {name = "sf_attn_sum", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12xf32>
      "affine.for"() ({
      ^bb0(%arg8: index):
        %15 = "memref.alloc"() {name = "sum_3", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xf32>
        %16 = "arith.constant"() {value = 0 : i32} : () -> i32
        %17 = "arith.constant"() {unsigned, value = 0 : index} : () -> index
        %18 = "arith.sitofp"(%16) : (i32) -> f32
        "affine.store"(%18, %15) {map = #map0, to = "sum_3"} : (f32, memref<1xf32>) -> ()
        "affine.for"() ({
        ^bb0(%arg9: index):
          %20 = "arith.constant"() {value = true} : () -> i1
          "scf.if"(%20) ({
            %21 = "affine.load"(%11, %arg8, %arg9) {from = "sf_attn_exp", map = #map1} : (memref<12x12xf32>, index, index) -> f32
            %22 = "affine.load"(%15) {from = "sum_3", map = #map0} : (memref<1xf32>) -> f32
            %23 = "arith.addf"(%21, %22) : (f32, f32) -> f32
            "affine.store"(%23, %15) {map = #map0, to = "sum_3"} : (f32, memref<1xf32>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "sf_r3", lower_bound = #map0, reduction, step = 1 : i32, upper_bound = #map4} : () -> ()
        %19 = "affine.load"(%15) {from = "sum_3", map = #map0} : (memref<1xf32>) -> f32
        "affine.store"(%19, %12, %arg8) {map = #map3, to = "sf_attn_sum"} : (f32, memref<12xf32>, index) -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "x_8", lower_bound = #map0, op_name = "sf_attn_sum", step = 1 : i32, upper_bound = #map4} : () -> ()
      %13 = "memref.alloc"() {name = "sf_attn_sfm", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x12xf32>
      "affine.for"() ({
      ^bb0(%arg8: index):
        "affine.for"() ({
        ^bb0(%arg9: index):
          %15 = "affine.load"(%11, %arg8, %arg9) {from = "sf_attn_exp", map = #map1} : (memref<12x12xf32>, index, index) -> f32
          %16 = "affine.load"(%12, %arg8) {from = "sf_attn_sum", map = #map3} : (memref<12xf32>, index) -> f32
          %17 = "arith.divf"(%15, %16) : (f32, f32) -> f32
          "affine.store"(%17, %13, %arg8, %arg9) {map = #map1, to = "sf_attn_sfm"} : (f32, memref<12x12xf32>, index, index) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "y_8", lower_bound = #map0, step = 1 : i32, upper_bound = #map4} : () -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "x_9", lower_bound = #map0, op_name = "sf_attn_sfm", step = 1 : i32, upper_bound = #map4} : () -> ()
      %14 = "memref.alloc"() {name = "sf_context_i", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<12x64xf32>
      "affine.for"() ({
      ^bb0(%arg8: index):
        "affine.for"() ({
        ^bb0(%arg9: index):
          %15 = "memref.alloc"() {name = "sum_4", operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xf32>
          %16 = "arith.constant"() {value = 0 : i32} : () -> i32
          %17 = "arith.constant"() {unsigned, value = 0 : index} : () -> index
          %18 = "arith.sitofp"(%16) : (i32) -> f32
          "affine.store"(%18, %15) {map = #map0, to = "sum_4"} : (f32, memref<1xf32>) -> ()
          "affine.for"() ({
          ^bb0(%arg10: index):
            %20 = "arith.constant"() {value = true} : () -> i1
            "scf.if"(%20) ({
              %21 = "affine.load"(%13, %arg8, %arg10) {from = "sf_attn_sfm", map = #map1} : (memref<12x12xf32>, index, index) -> f32
              %22 = "affine.load"(%9, %arg10, %arg9) {from = "sf_V_i", map = #map1} : (memref<12x64xf32>, index, index) -> f32
              %23 = "arith.mulf"(%21, %22) : (f32, f32) -> f32
              %24 = "affine.load"(%15) {from = "sum_4", map = #map0} : (memref<1xf32>) -> f32
              %25 = "arith.addf"(%23, %24) : (f32, f32) -> f32
              "affine.store"(%25, %15) {map = #map0, to = "sum_4"} : (f32, memref<1xf32>) -> ()
              "scf.yield"() : () -> ()
            }, {
            }) : (i1) -> ()
            "affine.yield"() : () -> ()
          }) {loop_name = "sf_r4", lower_bound = #map0, reduction, step = 1 : i32, upper_bound = #map4} : () -> ()
          %19 = "affine.load"(%15) {from = "sum_4", map = #map0} : (memref<1xf32>) -> f32
          "affine.store"(%19, %14, %arg8, %arg9) {map = #map1, to = "sf_context_i"} : (f32, memref<12x64xf32>, index, index) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "y_9", lower_bound = #map0, step = 1 : i32, upper_bound = #map7} : () -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "x_10", lower_bound = #map0, op_name = "sf_context_i", step = 1 : i32, upper_bound = #map4} : () -> ()
      "affine.for"() ({
      ^bb0(%arg8: index):
        "affine.for"() ({
        ^bb0(%arg9: index):
          %15 = "affine.load"(%14, %arg8, %arg9) {from = "sf_context_i", map = #map1} : (memref<12x64xf32>, index, index) -> f32
          "affine.store"(%15, %3, %arg8, %arg7, %arg9) {map = #map6, to = "sf_context"} : (f32, memref<12x768xf32>, index, index, index) -> ()
          "affine.yield"() : () -> ()
        }) {loop_name = "sf_ct_n", lower_bound = #map0, step = 1 : i32, upper_bound = #map7} : () -> ()
        "affine.yield"() : () -> ()
      }) {loop_name = "sf_ct_m", lower_bound = #map0, step = 1 : i32, upper_bound = #map4} : () -> ()
      "affine.yield"() : () -> ()
    }) {loop_name = "i", lower_bound = #map0, op_name = "sf_mutihead_loop", step = 1 : i32, upper_bound = #map4} : () -> ()
    "hcl.partition"(%7) {dim = 2 : ui32, factor = 8 : ui32, partition_kind = 2 : i32} : (memref<12x64xf32, #map5>) -> ()
    "hcl.partition"(%8) {dim = 2 : ui32, factor = 8 : ui32, partition_kind = 2 : i32} : (memref<12x64xf32, #map5>) -> ()
    "hcl.partition"(%10) {dim = 2 : ui32, factor = 8 : ui32, partition_kind = 2 : i32} : (memref<12x12xf32, #map5>) -> ()
    %4 = "hcl.create_op_handle"() {op_name = "sf_attention"} : () -> !hcl.OpHandle
    %5 = "hcl.create_loop_handle"(%4) {loop_name = "sf_r2"} : (!hcl.OpHandle) -> !hcl.LoopHandle
    %6:2 = "hcl.split"(%5) {factor = 8 : ui32} : (!hcl.LoopHandle) -> (!hcl.LoopHandle, !hcl.LoopHandle)
    "func.return"(%3) : (memref<12x768xf32>) -> ()
  }) {function_type = (memref<12x768xf32>, memref<768x768xf32>, memref<768xf32>, memref<768x768xf32>, memref<768xf32>, memref<768x768xf32>, memref<768xf32>) -> memref<12x768xf32>, itypes = "_______", otypes = "_", sym_name = "top"} : () -> ()
}) : () -> ()

Traceback (most recent call last):
  File "test.py", line 89, in <module>
    f = top(target)
  File "test.py", line 84, in top
    f = hcl.build(s, target=target)
  File "/work/shared/common/heterocl/heterocl/build_module.py", line 104, in build
    raise e
  File "/work/shared/common/heterocl/heterocl/build_module.py", line 83, in build
    lower(schedule)
  File "/work/shared/common/heterocl/heterocl/build_module.py", line 70, in lower
    schedule._module = _mlir_lower_pipeline(agnostic_module)
  File "/work/shared/common/heterocl/heterocl/build_module.py", line 45, in _mlir_lower_pipeline
    raise e
  File "/work/shared/common/heterocl/heterocl/build_module.py", line 40, in _mlir_lower_pipeline
    mlir_pass_manager.parse(pipeline).run(module)
RuntimeError: Failure while executing pass pipeline.